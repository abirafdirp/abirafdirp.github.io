<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Abirafdi Raditya Putra - Freelance Backend Developer</title>

    <link rel="stylesheet" type="text/css" href="css/index.css">
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
</head>
<body>
<section id="landing">
    <h1>ABIRAFDI RADITYA PUTRA</h1>
    <h3>FREELANCE BACKEND DEVELOPER</h3>
</section>
<section id="content">
asdassd
</section>
<script src="js/three.js"></script>
<script src="js/stats.js"></script>
<script>
    var stats = new Stats();
    stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild( stats.dom );

    // Define the standard global variables
    var scene,
            camera,
            renderer,
            squares = [];

    // Custom global variables
    var mouse = {x: 0, y: 0};
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    var raycaster = new THREE.Raycaster();
    var nameRaycaster = new THREE.Raycaster();
    var mouseMoved = false;

    init();
    spawnMeshes();
    animate();


    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        document.getElementById('landing').addEventListener('mousemove', onMouseMove, false);
        window.addEventListener( 'resize', onWindowResize, false );
    }

    function spawnMeshes() {
        for (var x = 0; x < 9; x += 0.2) {
            for (var y = 0; y < 9; y += 0.2) {
                var geometry = new THREE.PlaneGeometry(0.2, 0.2, 0.2);
                var wireframe = new THREE.WireframeGeometry( geometry );
                var material = new THREE.LineBasicMaterial({
                    color: 0x969393,
                    linewidth: 1
                });
                var _square = new THREE.LineSegments( wireframe, material );
                _square.material.depthTest = false;
                _square.translateX(x - 4);
                _square.translateY(y - 4);
                _square.material.opacity = 0.5;
                _square.material.transparent = true;
                scene.add( _square );
                squares.push(_square);
            }
        }
    }
    function onMouseMove(event){
        event.preventDefault();

        mouseMoved = true;

        var newMouseX = (event.clientX / window.innerWidth) * 2 - 1;
        var newMouseY = - (event.clientY / window.innerHeight) * 2 + 1;

        for (var i = 0; i < squares.length; i++){
            var _square = squares[i];
            _square.rotation.y =  - newMouseX - mouse.y;
        }
        mouse.x = newMouseX;
        mouse.y = newMouseY;
    }

    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }


    function animate() {
        stats.begin();
        renderer.setSize( window.innerWidth, window.innerHeight );
        // calculate objects intersecting the picking ray

        // update the picking ray with the camera and mouse position
        // raycaster.setFromCamera( mouse, camera );
        // var intersects = raycaster.intersectObjects ( scene.children, true );
        // var intersectedObjects = [];
        // for ( var i = 0; i < intersects.length; i++ ) {
        //     var intersectedObject = intersects[ i ].object;
        //     if (intersectedObject.material.opacity > -0.05)
        //         intersectedObject.material.opacity -= 0.0003;
        //     intersectedObjects.push(intersects[i].object);
        // }

        for (var i = 0; i < 80; i++){
            var _square = squares[ Math.floor( Math.random() * squares.length )  ];
            if (_square.material.opacity < 0.8){
                _square.material.opacity += 0.02;
            }
        }



        nameRaycaster.setFromCamera( new THREE.Vector2(0, 0), camera );
        var nameIntersectts = nameRaycaster.intersectObjects ( scene.children );
        for ( var i = 0; i < nameIntersectts.length; i++ ) {
            nameIntersectts[i].object.material.opacity = 0;
        }

        renderer.render( scene, camera );
        stats.end();
        requestAnimationFrame( animate );
    }
</script>
</body>
</html>